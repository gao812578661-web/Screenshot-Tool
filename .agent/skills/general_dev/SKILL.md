---
name: general_development
description: 遵循“用户核心开发协议”的轻量化通用开发工作流。包含分析、计划、任务分解与执行验证。
---

# 通用开发技能 (General Development Skill)

本技能旨在贯彻“用户核心开发协议”，确保开发过程高效、透明且结果可控。

## 1. 核心理念 (Core Philosophy)

> **简洁至上 (KISS)**
> 任何设计与代码应保持最简形式，避免过度工程化。先让它工作，再让它完美。

> **深度分析 (First Principles)**
> 遇到问题时，回归基本原理进行拆解，而非盲目尝试或照搬现有方案。善用工具获取第一手信息。

> **事实为本 (Fact-Based)**
> 一切决策基于日志、测试结果或官方文档。对不确定的假设保持怀疑，并优先验证。

## 2. 标准开发流程 (Standard Workflow)

### 第一阶段：构思方案 (Draft Plan)
1.  **明确需求**: 仔细阅读用户请求，确认最终目标。
2.  **现状调研**: 检查现有代码 (`codebase_search`) 和知识库 (KIs)。
3.  **制定计划**: 创建或更新 `implementation_plan.md`。
    *   **目标 (Goal)**: 一句话描述要做什么。
    *   **关键变更 (Changes)**: 列出受影响的文件和逻辑。
    *   **验证方案 (Verification)**: 如何证明功能正常（测试用例、手动步骤）。

### 第二阶段：提请审核 (Request Review)
1.  使用 `notify_user` 将计划呈现给用户。
2.  **等待批准**: 根据用户反馈调整计划，直到获得明确指令。

### 第三阶段：任务分解 (Breakdown to Tasks)
1.  **创建/更新任务清单**: 维护 `task.md`。
2.  **细化粒度**: 将大任务拆解为可独立执行的小步骤（如“实现 UI”、“编写逻辑”、“增加测试”）。
3.  **动态调整**: 开发中遇到新问题，及时回填到任务清单。

### 第四阶段：执行 (Execute)
1.  **任务边界**: 每次操作前调用 `task_boundary`，明确当前正在做什么。
2.  **渐进式编码**:
    *   小步快跑，频繁验证。
    *   代码风格统一，关键逻辑添加注释。
3.  **验证**:
    *   运行代码，检查日志和输出。
    *   创建 `walkthrough.md` 记录验证过程和结果截图。

### 第五阶段：交付与归档 (Delivery & Archive)
1.  **本地提交**: 确保代码变更已通过 `git commit` 保存到本地仓库。
2.  **远程推送**: **必须**主动询问用户是否将代码推送到 GitHub (`git push`)，以防止数据丢失。

## 3. 常见场景指南 (Common Scenarios)

### 新功能开发
*   先定义接口和数据结构，再实现细节。
*   优先打通核心流程（Happy Path），再处理边缘情况。

### Bug 修复
*   **重现**: 必须先能稳定复见 Bug。
*   **定位**: 使用二分法或日志定位根因。
*   **修复**: 针对根因修复，避免掩盖问题。
*   **验证**: 确认 Bug 消除且无回归。

### 重构
*   确保有测试覆盖或手动验证手段。
*   小步提交，保持代码处于可运行状态。

## 4. 输出规范 (Output Standards)

*   **语言要求**：所有回复、思考过程及任务清单, 均须使用 **中文**。
*   **格式**: Markdown 格式清晰，重点加粗。
*   **指令响应**: 随时准备响应 `'Implementation Plan,Task List and Thought in Chinese'` 指令。

### 5. 调试与功能迭代 (Debugging & Iteration)

#### (1) 功能移除规范 (Feature Removal)
- **UI/视图清理**: 从布局文件及视图代码中彻底移除入口控件、样式及废弃的资源。
- **逻辑剥离**: 清除对应的业务逻辑、事件处理程序、成员变量及依赖项。
- **物理清理**: 确认关联的类文件、资源文件及配置文件已物理删除，避免残留死代码。
- **环境回退**: 若功能开启了特殊的全局配置（如特定的编译器参数、系统权限申请、不安全代码支持等），在移除功能后必须及时回退，以维持系统安全基线。

#### (2) UI 交互与层级管理 (Layering & Interaction)
- **Z 轴层级意识**: 
  - 信息展示层（如提示信息、识别层）原则上应位于内容交互层下方。
  - 核心互动层（如笔触绘图、拖拽选择）应保持在最顶层，确保用户操作不会被遮挡，且视觉反馈符合自然叠加逻辑。
- **定位一致性**: 
  - 在发生布局变更（如从自由定位切换到网格/流式布局）时，必须确保坐标系及原点参考逻辑的一致。
  - 若布局变动导致动态定位坐标失效，应通过引入定位透明容器或中转层，确保组件在多分辨率下的对齐精度。

#### (3) 操作逻辑优化 (User Experience Logic)
- **一键触达**: 避免在主操作按钮上应用具有“隐性切换开关”性质的交互逻辑。
- **原子化动作**: 交互按钮应以“执行功能”为首要目标。确在任何当前 UI 状态下，单次点击均能产生确定的功能反馈（如弹出窗口或生成结果），而非仅是关闭之前的状态图层。

#### (4) 发布与交付规范 (Release & Delivery)
- **执行环境解耦**: 优先采用独立打包（Self-Contained）方案，降低对目标机器运行时的依赖。
- **外部依赖闭环**: 识别并手动携带难以自动集成的非托管库（如渲染引擎 DLL、驱动级组件等），确保跨环境的功能稳定性。
- **多层级交付文档**: 发布包应包含分层文档：
  - **ReadMe**: 极简文本，解决“如何启动与基础操作”的核心问题。
  - **用户手册 (User Guide)**: 详实文档，提供功能深度解析、热键及高级使用技巧。
  - **发行说明 (Release Info)**: 记录版本特性、更新日志及开发者联系方式。